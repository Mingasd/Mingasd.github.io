---
layout: post
title: 二叉树遍历总结
featured-img: 2021-09-17
---

### 二叉树遍历是二叉树中最基本也是最重要的算法

二叉树遍历算法有：

- 前序遍历：依据 中-左-右 顺序对二叉树进行遍历节点
- 中序遍历：依据 左-中-右 顺序对二叉树进行遍历节点
- 后续遍历：依据 左-右-中 顺序对二叉树进行遍历节点
- 层序遍历：依据二叉树的深度，从上到下，在每层中依据从左到右的顺序遍历节点



树结构代码

```java
class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() {}
     TreeNode(int val) { this.val = val; }
     TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
}
```



#### 前序遍历

![](https://gitee.com/wecouldwin/blog-imag/raw/master/img/20210917211548.png)

在上图二叉树中执行前序遍历算法得到的结果将会是

![](https://gitee.com/wecouldwin/blog-imag/raw/master/img/20210917212753.png)

##### 递归算法

```java
public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> ans = new LinkedList<>();
        preorderDfs(root, ans);
        return ans;
    }

    private void preorderDfs(TreeNode node, List<Integer> ans) {
        if (node==null)
            return;
        ans.add(node.val);
        preorderDfs(node.left,ans);
        preorderDfs(node.right,ans);
    }
```

##### 迭代算法

递归算法较为简单，重点需要掌握的是迭代算法

```java
 public List<Integer> preOrderTraversal(TreeNode root) {
        List<Integer> ans = new LinkedList<>();
        if (root == null)
            return ans;
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node!=null){
                ans.add(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop().right;
        }
        return ans;
    }
```

利用栈模拟递归栈来实现迭代算法，使用两层`while`递归。

第一层循环条件为栈不为空，或者当前需要处理的节点不为空(主要是用来弥补第一次循环中，栈为空的情况)。

第二层循环条件为当前需要处理的节点不为空，此循环内作用是一直遍历完左节点。由于是前序遍历，循环体内**首先访问当前节点的数值**，**当前节点可以视为在当前迭代中扮演的是根节点的角色**，之后将当前节点入栈，以便在遍历完左节点之后，访问右节点。那访问右节点自然就是在当前循环结束之后，通过栈获取右节点。

#### 中序遍历

![](https://gitee.com/wecouldwin/blog-imag/raw/master/img/20210917211548.png)

在上图中执行中序遍历算法得到的结果将会是

![](https://gitee.com/wecouldwin/blog-imag/raw/master/img/20210917211846.png)

##### 递归算法

```java
public List<Integer> inorderTraversal(TreeNode root){
        List<Integer> ans = new LinkedList<>();
        inorderDfs(root, ans);
        return ans;
    }

    private void inorderDfs(TreeNode node, List<Integer> ans) {
        if (node==null)
            return;
        inorderDfs(node.left, ans);
        ans.add(node.val);
        inorderDfs(node.right,ans);
    }
```

##### 迭代算法

同上，迭代法更为重要

```java
public List<Integer> inOrderTraversal(TreeNode root) {
        List<Integer> ans = new LinkedList<>();
        if (root == null)
            return ans;
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node!=null){
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            ans.add(node.val);
            node=node.right;
        }
        return ans;
    }
```

中序遍历的迭代算法同前序遍历相比差别不大，也是采用两层`while`循环进行迭代，不同的是对于节点值得访问顺序，因为中序遍历是按照 左-中-右 顺序，因此**访问节点值必然是在遍历完左节点之后**再进行，因此代码实现是在第一层循环结束之后，取出栈中节点后，在获取右节点之前，访问节点值。

#### 后序遍历

![](https://gitee.com/wecouldwin/blog-imag/raw/master/img/20210917211548.png)

在上图中执行中序遍历算法得到的结果将会是

![](https://gitee.com/wecouldwin/blog-imag/raw/master/img/20210917213843.png)

##### 递归算法

```java
public List<Integer> postorderTraversal(TreeNode root){
        List<Integer> ans = new LinkedList<>();
        postorderDfs(root, ans);
        return ans;
    }

    private void postorderDfs(TreeNode node, List<Integer> ans) {
        if (node==null)
            return;
        inorderDfs(node.left, ans);
        inorderDfs(node.right,ans);
        ans.add(node.val);
    }
```

##### 迭代算法

后序遍历的迭代算法较上面两种而言更加复杂

```java
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
```

后序遍历同样是使用两次循环，最大的不同是需要保存上一个访问节点值得那个节点，在结束第二层循环之后（遍历完左节点）,

